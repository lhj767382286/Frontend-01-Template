# 表达式及类型转换

## Expression

### Tree vs Priority

* 优先级 - 其实是通过表达式生成树的方式实现的
* 四则运算：
  * 数学角度：运算符的优先级
  * 语言的实现与定义的角度：树的结构 (下层结构优先级更高)
* 产生式（第二周内容）：
  * **在定义加法、乘法表达式的时，把乘法表达式作为加法表达式的子规则**
  * 这样在解析形成 AST 时，乘法节点就一定是加法节点的子节点，从而会被优先计算



```
<AdditiveExpression> ::= <MultiplicativeExpression> | 
	<AdditiveExpression> "+" <MultiplicativeExpression>
	
<MultiplicativeExpression> ::= <DecimalExpress>  |
	<MultiplicativeExpression> "*" <DecimalExpress> 
```



因此，我们可以通过文法的嵌套，实现对运算优先级的支持。这样我们在解析  `1 + 2 * 3` 这个算术表达式时会形成类似下面的 AST：

![image-20200424164904296](https://tva1.sinaimg.cn/large/007S8ZIlgy1ge4ydphxd6j30bv06j74f.jpg)



下面来看一下优先级最高的几个运算符：Member、New



#### Member

> Member 运算，成员访问/属性访问。ECMA 262 P201

* `a.b`
  * 访问属性
* `a[b]`
  * 通过变量去访问属性
  * 动态语言，相当于具备了 `java` 的反射能力
* foo \`string\`
* `super.b`
* `super['b']`
* `new.target`
* `new Foo()`



##### foo \`string\`

```javascript
let name = 'irving';
function foo () {
  console.log(arguments);
}
foo `Hello ${name}!`; // [['Hello', '!'], 'irving']
```



##### new.target

* 作用：

  * 检测函数或构造方法是否是通过 [new](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/new) 运算符被调用的
  * 在通过 [new](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/new) 运算符被初始化的函数或构造方法中，`new.target` 返回一个指向构造方法或函数的引用

* 限制：

  * 只能在函数中使用
  * 在普通的函数调用中，`new.target` 的值是 `undefined`

  

```javascript
// 1. 普通函数
function Foo() {
	console.log(new.target);
  // if (!new.target) // 抛错
}

Foo(); // undefined
new Foo(); // foo{..}


// 2. 构造方法
class A {
  constructor() {
    console.log(new.target)
    console.log(new.target.name);
  }
}

class B extends A { constructor() { super(); } }

A(); // TypeError: Class constructor A cannot be invoked without 'new'
new A(); // "A"
new B(); // "B"


// 3. 伪造对象
var fakeObj = {};
Object.setPrototypeOf(fakeObj, Foo.prototype);
fakeObj.constructor = Foo;
Foo.apply(fakeObj);
// ES5 语法中无法判断 fakeObj 是否是 new 出来的： instanceof 走的是原型链
// 所以引入 new.target. 判断是不是被 new 运算符调用
```



#### New

* `new Foo`

```javascript
// new
new a();
new new a();
// 带括号的优先级更高
function cls1(s){
  console.log(s)
}
function cls2(s) {
	console.log("2", s);
  return cls1;
}

new new cls2("good")

// 2 good
// undefined
// cls1 {}
```

#### Call

> 函数调用

* foo()
* super()
* foo()['b']
* foo().b
* foo() \`abc\`



```javascript
new a()['b']
```



Member New Call 其实是为了让 New 更符合预期合理



#### Left Handside

> 可以理解为 = 号左右边

左值表达式：

极限现象就是 call

运行时是个 reference

语法上是个 left handside





```
a.b = c;
a + b = c;
```

#### Right Handside

* Update
  * a ++
  * a --
  * -- a
  * ++ a



```javascript
++ a ++
++ (a++)

// P178 no LineTerminator  语法与词法特殊之处

var a = 1, b = 1, c = 1

a
++
b
++
c

// a = 1, b = 2, c = 2

a/*

*/++
b/*
*/

// a = 1, b = 3
```





* Unary 单目运算符
  * Delete a.b
  * void foo()
  * typeof a
  * `+ a`
  * `- a`
  * `~ a`
  * `!a`
  * `await a`



```javascript
void 在 js 中是一个运算符

function(var i = 0; i < 10; i++) {
  var button = document.createElement("button");
  document.body.appendChild(button)
  button.innterHTML = i
  void function(i){
    button.onClick = function () {
      console.log(i)
    }(i);
  }
}

// 加 void，
// 语义正确
// 如果前面忘记写分号，用"("会有问题
```



* Exponental
  * `**` 

```
唯一一个右结合的运算符
```



* Multiplicative
  * `* / %`
* Additive
  * `+ -`
* `Shift`
  * ``



````
逻辑运算 -> 短路逻辑


?:

,

=> 
````



### [LHS and RHS](https://segmentfault.com/a/1190000003793498)

* 是引擎执行阶段时执行的两种变量的查找方式
  * LHS 查找发生在：赋值给变量的时候，如: `var a = 2;`
  * RHS 查找发生在：查找某个变量的值，如: `console.log(a);`
* 区分：
  * 根据查找的目的进行区分
    * LHS 查找的目的是 **对变量进行赋值** - 写
    * RHS 查找的目的是 **获取变量的值** - 读
  * 此外，LHS 表示存储计算机内存的对象



```javascript
var c = 1;	// LHS lookup (目的是对变量 c 赋值)

var foo = function (a) { // 2 个 LHS 对变量 foo 及 形式参数 a 赋值)
  var b = a;	// LHS (对变量 b 赋值) / RHS (获取变量 a 的值)
  return a + b + c;	// 3 个 RHS (获取变量 a, b, c 的值）
}

foo(2)	// RHS (目的是获取 foo 的值)
```





## Reference

delete删除的是引用的地址

- Object
- Key



```javascript
delete
assign
```





```
var obj2 = {   [Symbol.toPrimitive](hint) {     if (hint == "number") {       return 10;     }     if (hint == "string") {       return "hello";     }     return true;   } }; console.log(+obj2);     // 10      -- hint 参数值是 "number" console.log(`${obj2}`); // "hello" -- hint 参数值是 "string" console.log(obj2 + ""); // "true"  -- hint 参数值是 "default"
```

![image-20200423221042398](https://tva1.sinaimg.cn/large/007S8ZIlgy1ge4222bsbmj30pi09o75a.jpg)

![image-20200423221517936](https://tva1.sinaimg.cn/large/007S8ZIlgy1ge426uul3aj30vy0dgdmd.jpg)







### Number 类型



浮点数，运算会造成精度丢失



https://jsfiddle.net/pLh8qeor/19/



十进制转二进制 整数部分：除二取余 小数部分：乘二取整 0.1 * 2 = 0.2 --> 0 0.2 * 2 = 0.4 --> 0 0.4 * 2 = 0.8 --> 0 0.8 * 2 = 1.6 --> 1 --> 0.6 0.6 * 2 = 1.2 --> 1 0.2 * 2 = 0.4 --> 0 0.4 * 2 = 0.8 --> 0 0.8 * 2 = 1.6 --> 1 --> 0.6 ... 循环

